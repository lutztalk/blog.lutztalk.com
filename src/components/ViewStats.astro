---
type Props = {
  slug: string;
  class?: string;
  size?: "sm" | "lg";
};

const { slug, class: className = "", size = "sm" } = Astro.props;
---

<div 
  class:list={["opacity-80 text-sm", { "sm:text-base": size === "lg" }, className]}
  data-view-stats
  data-slug={slug}
>
  <span aria-hidden="true" class="opacity-60 mx-1 hidden view-count-separator">•</span>
  <span id={`view-count-${slug}`} class="view-count"></span>
  <span aria-hidden="true" class="opacity-60 mx-1 hidden viewers-separator">•</span>
  <span id={`viewers-count-${slug}`} class="viewers-count hidden"></span>
</div>

<script define:vars={{ postSlug: slug }} is:inline>
  (function() {
    const slug = postSlug;
    let viewersInterval = null;
    let viewInterval = null;
    let isInitialized = false;
    let viewCountEl = null;
    let viewersCountEl = null;
    let viewCountSeparatorEl = null;
    let viewersSeparatorEl = null;
    let viewerId = null;
    let viewTrackingInProgress = false; // Flag to prevent concurrent tracking

    // Update view count
    function updateViewCount() {
      if (!viewCountEl) return;
      
      fetch(new URL(`/api/views/${slug}`, window.location.origin))
        .then(res => {
          if (!res.ok) {
            return res.json().then(err => {
              console.error('[ViewStats] API error:', err);
              throw new Error(`HTTP error! status: ${res.status}, ${JSON.stringify(err)}`);
            });
          }
          return res.json();
        })
        .then(data => {
          console.log('[ViewStats] Received count data:', data);
          if (data.count !== undefined && viewCountEl) {
            const count = Number(data.count);
            if (count > 0) {
              viewCountEl.textContent = count === 1 
                ? '1 person has read this' 
                : `${count.toLocaleString()} people have read this`;
              if (viewCountSeparatorEl) viewCountSeparatorEl.classList.remove('hidden');
            } else {
              viewCountEl.textContent = '';
              if (viewCountSeparatorEl) viewCountSeparatorEl.classList.add('hidden');
            }
          }
        })
        .catch((error) => {
          console.error('[ViewStats] Error fetching view count:', error);
          if (viewCountEl) {
            viewCountEl.textContent = '';
            if (viewCountSeparatorEl) viewCountSeparatorEl.classList.add('hidden');
          }
        });
    }

    // Update active viewers
    function updateViewers() {
      if (!viewersCountEl || !viewerId) return;
      
      fetch(new URL(`/api/viewers/${slug}`, window.location.origin), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Viewer-ID': viewerId,
        },
      })
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          console.log('[ViewStats] Active viewers response:', data);
          if (data.count !== undefined && viewersCountEl) {
            const totalCount = Number(data.count);
            // Count includes current viewer, so subtract 1 to get "others"
            const othersCount = totalCount > 0 ? totalCount - 1 : 0;
            
            if (othersCount > 0) {
              viewersCountEl.textContent = othersCount === 1 
                ? '1 viewing' 
                : `${othersCount} viewing`;
              viewersCountEl.classList.remove('hidden');
              if (viewersSeparatorEl) viewersSeparatorEl.classList.remove('hidden');
            } else {
              viewersCountEl.classList.add('hidden');
              if (viewersSeparatorEl) viewersSeparatorEl.classList.add('hidden');
            }
          }
        })
        .catch((error) => {
          console.error('[ViewStats] Error fetching active viewers:', error);
          if (viewersCountEl) {
            viewersCountEl.classList.add('hidden');
          }
          if (viewersSeparatorEl) {
            viewersSeparatorEl.classList.add('hidden');
          }
        });
    }

    function initViewStats() {
      // Only track views on individual post pages (URLs starting with /posts/)
      const currentPath = window.location.pathname;
      if (!currentPath.startsWith('/posts/')) {
        console.log('[ViewStats] Not a post page, skipping view tracking:', currentPath);
        return;
      }

      // Prevent multiple initializations
      if (isInitialized) {
        console.log('[ViewStats] Already initialized, skipping');
        return;
      }

      const container = document.querySelector(`[data-view-stats][data-slug="${slug}"]`);
      if (!container) {
        console.warn('[ViewStats] Container not found for slug:', slug);
        return;
      }

      viewCountEl = container.querySelector(`#view-count-${slug}`);
      viewersCountEl = container.querySelector(`#viewers-count-${slug}`);
      viewCountSeparatorEl = container.querySelector(`.view-count-separator`);
      viewersSeparatorEl = container.querySelector(`.viewers-separator`);
      if (!viewCountEl || !viewersCountEl) {
        console.warn('[ViewStats] Elements not found for slug:', slug);
        return;
      }

      // Generate or get viewer ID
      viewerId = sessionStorage.getItem('viewer-id');
      if (!viewerId) {
        viewerId = `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        sessionStorage.setItem('viewer-id', viewerId);
      }

      // Track if view has been counted for this specific page load using sessionStorage
      // Use a simpler key that's unique per slug per session
      const viewTrackingKey = `view-tracked-${slug}`;
      const viewTracked = sessionStorage.getItem(viewTrackingKey);
      
      console.log('[ViewStats] Checking view tracking:', {
        slug,
        key: viewTrackingKey,
        tracked: !!viewTracked,
        inProgress: viewTrackingInProgress,
        pathname: window.location.pathname
      });

      // Clean up existing intervals
      if (viewersInterval) clearInterval(viewersInterval);
      if (viewInterval) clearInterval(viewInterval);

      // Track view (only once per page load, using sessionStorage for persistence)
      // Use both sessionStorage check AND in-memory flag to prevent race conditions
      if (!viewTracked && !viewTrackingInProgress) {
        // Set both flags immediately to prevent concurrent calls
        viewTrackingInProgress = true;
        sessionStorage.setItem(viewTrackingKey, 'true');
        console.log('[ViewStats] Tracking view for slug:', slug, 'key:', viewTrackingKey);
        
        fetch(new URL(`/api/views/${slug}`, window.location.origin), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Viewer-ID': viewerId,
          },
        })
        .then(res => {
          if (!res.ok) {
            // Remove flags on error so we can retry
            sessionStorage.removeItem(viewTrackingKey);
            viewTrackingInProgress = false;
            return res.json().then(err => {
              console.error('[ViewStats] POST error:', err);
              throw new Error(`HTTP error! status: ${res.status}, ${JSON.stringify(err)}`);
            });
          }
          return res.json();
        })
        .then(data => {
          console.log('[ViewStats] POST response:', data);
          viewTrackingInProgress = false; // Clear flag on success
          // Update view count immediately after tracking
          if (data.count !== undefined && viewCountEl) {
            const count = Number(data.count);
            if (count > 0) {
              viewCountEl.textContent = count === 1 
                ? '1 person has read this' 
                : `${count.toLocaleString()} people have read this`;
              if (viewCountSeparatorEl) viewCountSeparatorEl.classList.remove('hidden');
            } else {
              viewCountEl.textContent = '';
              if (viewCountSeparatorEl) viewCountSeparatorEl.classList.add('hidden');
            }
          }
        })
        .catch((error) => {
          console.error('[ViewStats] Error tracking view:', error);
          viewTrackingInProgress = false; // Clear flag on error
          sessionStorage.removeItem(viewTrackingKey); // Remove on error so we can retry
        });
      } else {
        if (viewTracked) {
          console.log('[ViewStats] View already tracked for this page load (sessionStorage)');
        }
        if (viewTrackingInProgress) {
          console.log('[ViewStats] View tracking already in progress, skipping');
        }
        // Still update the display even if already tracked
        updateViewCount();
      }

      // Mark as initialized
      isInitialized = true;

      // Initial load
      updateViewCount();
      updateViewers();

      // Update viewers every 10 seconds (heartbeat)
      viewersInterval = setInterval(updateViewers, 10000);

      // Update view count every 30 seconds
      viewInterval = setInterval(updateViewCount, 30000);

      // Clean up on page unload - try to remove viewer immediately
      const cleanup = () => {
        if (viewersInterval) clearInterval(viewersInterval);
        if (viewInterval) clearInterval(viewInterval);
        
        // Try to remove viewer from active list (fire and forget)
        if (viewerId) {
          const removeUrl = new URL(`/api/viewers/${slug}?remove=true`, window.location.origin);
          
          // Use fetch with keepalive for reliable delivery on page unload
          fetch(removeUrl.toString(), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Viewer-ID': viewerId,
            },
            body: JSON.stringify({ viewerId }),
            keepalive: true, // Ensures request completes even if page unloads
          }).catch(() => {
            // Ignore errors on unload - cleanup will happen via TTL anyway
          });
        }
      };
      
      window.addEventListener('beforeunload', cleanup);
      window.addEventListener('pagehide', cleanup); // Also handle pagehide for better mobile support
    }

    // Use a single initialization function that handles both cases
    function initializeOnce() {
      // Only track views on individual post pages (URLs starting with /posts/)
      const currentPath = window.location.pathname;
      if (!currentPath.startsWith('/posts/')) {
        return; // Don't initialize on non-post pages
      }

      // Prevent multiple initializations - check both flags
      if (isInitialized) {
        console.log('[ViewStats] Already initialized, skipping');
        return;
      }

      initViewStats();
    }

    // Run on initial load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeOnce);
    } else {
      initializeOnce();
    }

    // Run on Astro view transitions (reset for new page)
    document.addEventListener('astro:page-load', () => {
      // Only reset if we're on a post page
      const currentPath = window.location.pathname;
      if (!currentPath.startsWith('/posts/')) {
        return; // Don't initialize on non-post pages
      }

      // Clear the tracking flag for this slug (will be set again if needed)
      const oldTrackingKey = `view-tracked-${slug}`;
      sessionStorage.removeItem(oldTrackingKey);
      isInitialized = false;
      viewTrackingInProgress = false; // Reset tracking flag
      // Reset element references
      viewCountEl = null;
      viewersCountEl = null;
      viewCountSeparatorEl = null;
      viewersSeparatorEl = null;
      initializeOnce();
    });
  })();
</script>


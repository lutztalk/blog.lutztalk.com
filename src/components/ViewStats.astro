---
type Props = {
  slug: string;
  class?: string;
  size?: "sm" | "lg";
};

const { slug, class: className = "", size = "sm" } = Astro.props;
---

<div 
  class:list={["opacity-80 text-sm", { "sm:text-base": size === "lg" }, className]}
  data-view-stats
  data-slug={slug}
>
  <span aria-hidden="true" class="opacity-60 mx-1 hidden view-count-separator">•</span>
  <span id={`view-count-${slug}`} class="view-count"></span>
  <span aria-hidden="true" class="opacity-60 mx-1 hidden viewers-separator">•</span>
  <span id={`viewers-count-${slug}`} class="viewers-count hidden"></span>
</div>

<script define:vars={{ postSlug: slug }} is:inline>
  function initViewStats() {
    const slug = postSlug;
    const container = document.querySelector(`[data-view-stats][data-slug="${slug}"]`);
    if (!container) {
      console.warn('[ViewStats] Container not found for slug:', slug);
      return;
    }

    const viewCountEl = container.querySelector(`#view-count-${slug}`);
    const viewersCountEl = container.querySelector(`#viewers-count-${slug}`);
    const viewCountSeparatorEl = container.querySelector(`.view-count-separator`);
    const viewersSeparatorEl = container.querySelector(`.viewers-separator`);
    if (!viewCountEl || !viewersCountEl) {
      console.warn('[ViewStats] Elements not found for slug:', slug);
      return;
    }

    // Generate or get viewer ID
    let viewerId = sessionStorage.getItem('viewer-id');
    if (!viewerId) {
      viewerId = `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      sessionStorage.setItem('viewer-id', viewerId);
    }

    let viewersInterval = null;
    let viewInterval = null;

    // Track view (only once per session)
    const viewTracked = sessionStorage.getItem(`view-tracked-${slug}`);
    if (!viewTracked) {
      fetch(new URL(`/api/views/${slug}`, window.location.origin), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Viewer-ID': viewerId,
        },
      })
        .then(res => res.json())
        .then(data => {
          // Update view count immediately after tracking
          if (data.count !== undefined && viewCountEl) {
            const count = data.count;
            const otherCount = count - 1; // Exclude current viewer
            if (otherCount > 0) {
              viewCountEl.textContent = otherCount === 1 
                ? '1 person has read this' 
                : `${otherCount.toLocaleString()} people have read this`;
              if (viewCountSeparatorEl) viewCountSeparatorEl.classList.remove('hidden');
            } else {
              viewCountEl.textContent = '';
              if (viewCountSeparatorEl) viewCountSeparatorEl.classList.add('hidden');
            }
          }
        })
        .catch((error) => {
          console.error('[ViewStats] Error tracking view:', error);
        });
      sessionStorage.setItem(`view-tracked-${slug}`, 'true');
    }

    // Update view count
    function updateViewCount() {
      fetch(new URL(`/api/views/${slug}`, window.location.origin))
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          if (data.count !== undefined) {
            const count = data.count;
            const otherCount = count - 1; // Exclude current viewer
            if (viewCountEl) {
              if (otherCount > 0) {
                viewCountEl.textContent = otherCount === 1 
                  ? '1 person has read this' 
                  : `${otherCount.toLocaleString()} people have read this`;
                if (viewCountSeparatorEl) viewCountSeparatorEl.classList.remove('hidden');
              } else {
                // Don't show if no other people have read it
                viewCountEl.textContent = '';
                if (viewCountSeparatorEl) viewCountSeparatorEl.classList.add('hidden');
              }
            }
          } else if (viewCountEl) {
            viewCountEl.textContent = '';
            if (viewCountSeparatorEl) viewCountSeparatorEl.classList.add('hidden');
          }
        })
        .catch((error) => {
          console.error('[ViewStats] Error fetching view count:', error);
          if (viewCountEl) {
            viewCountEl.textContent = '';
            if (viewCountSeparatorEl) viewCountSeparatorEl.classList.add('hidden');
          }
        });
    }

    // Update active viewers
    function updateViewers() {
      fetch(new URL(`/api/viewers/${slug}`, window.location.origin), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Viewer-ID': viewerId,
        },
      })
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          if (data.count !== undefined && viewersCountEl) {
            const count = data.count;
            if (count > 1) {
              const viewerCount = count - 1;
              viewersCountEl.textContent = viewerCount === 1 
                ? '1 viewing' 
                : `${viewerCount} viewing`;
              viewersCountEl.classList.remove('hidden');
              if (viewersSeparatorEl) viewersSeparatorEl.classList.remove('hidden');
            } else {
              viewersCountEl.classList.add('hidden');
              if (viewersSeparatorEl) viewersSeparatorEl.classList.add('hidden');
            }
          }
        })
        .catch((error) => {
          console.error('[ViewStats] Error fetching active viewers:', error);
          if (viewersCountEl) {
            viewersCountEl.classList.add('hidden');
          }
          if (viewersSeparatorEl) {
            viewersSeparatorEl.classList.add('hidden');
          }
        });
    }

    // Clean up existing intervals
    if (viewersInterval) clearInterval(viewersInterval);
    if (viewInterval) clearInterval(viewInterval);

    // Initial load
    updateViewCount();
    updateViewers();

    // Update viewers every 10 seconds
    viewersInterval = setInterval(updateViewers, 10000);

    // Update view count every 30 seconds
    viewInterval = setInterval(updateViewCount, 30000);

    // Clean up on page unload
    const cleanup = () => {
      if (viewersInterval) clearInterval(viewersInterval);
      if (viewInterval) clearInterval(viewInterval);
    };
    window.addEventListener('beforeunload', cleanup);
    
    // Return cleanup function for Astro view transitions
    return cleanup;
  }

  // Run on initial load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initViewStats);
  } else {
    initViewStats();
  }

  // Run on Astro view transitions
  document.addEventListener('astro:page-load', initViewStats);
</script>

